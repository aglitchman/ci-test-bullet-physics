diff --git a/build_tools/sdk.py b/build_tools/sdk.py
index 75d8864a2f..7b95642388 100644
--- a/build_tools/sdk.py
+++ b/build_tools/sdk.py
@@ -71,8 +71,8 @@ ANDROID_64_NDK_API_VERSION='21' # Android 5.0
 # Win32
 
 # The version we have prepackaged
-VERSION_WINDOWS_SDK_10="10.0.20348.0"
-VERSION_WINDOWS_MSVC_2022="14.37.32822"
+VERSION_WINDOWS_SDK_10="10.0.26100.0"
+VERSION_WINDOWS_MSVC_2022="14.44.35207"
 PACKAGES_WIN32_TOOLCHAIN=f"Microsoft-Visual-Studio-2022-{VERSION_WINDOWS_MSVC_2022}"
 PACKAGES_WIN32_SDK_10=f"WindowsKits-{VERSION_WINDOWS_SDK_10}"
 
diff --git a/engine/gamesys/src/gamesys/components/bullet3d/comp_collision_object_bullet3d.cpp b/engine/gamesys/src/gamesys/components/bullet3d/comp_collision_object_bullet3d.cpp
index 6b88707a93..e867d75406 100644
--- a/engine/gamesys/src/gamesys/components/bullet3d/comp_collision_object_bullet3d.cpp
+++ b/engine/gamesys/src/gamesys/components/bullet3d/comp_collision_object_bullet3d.cpp
@@ -77,6 +77,8 @@ namespace dmGameSystem
     {
         DM_STATIC_ASSERT(sizeof(ShapeInfo::m_BoxDimensions) <= sizeof(dmVMath::Vector3), Invalid_Struct_Size);
 
+        dmLogInfo("PATCH: Bullet Physics 3D New World");
+
         PhysicsContextBullet3D* physics_context = (PhysicsContextBullet3D*) params.m_Context;
         if (params.m_MaxComponentInstances == 0 || physics_context->m_Context == 0x0)
         {
@@ -598,6 +600,31 @@ namespace dmGameSystem
             out_value.m_Variant = dmGameObject::PropertyVar(dmPhysics::GetAngularDamping3D(component->m_Object3D));
             return dmGameObject::PROPERTY_RESULT_OK;
         }
+        else if (params.m_PropertyId == PROP_LINEAR_FACTOR)
+        {
+            out_value.m_Variant = dmGameObject::PropertyVar(dmPhysics::GetLinearFactor3D(component->m_Object3D));
+            return dmGameObject::PROPERTY_RESULT_OK;
+        }
+        else if (params.m_PropertyId == PROP_ANGULAR_FACTOR)
+        {
+            out_value.m_Variant = dmGameObject::PropertyVar(dmPhysics::GetAngularFactor3D(component->m_Object3D));
+            return dmGameObject::PROPERTY_RESULT_OK;
+        }
+        else if (params.m_PropertyId == PROP_CONTACT_PROCESSING_THRESHOLD)
+        {
+            out_value.m_Variant = dmGameObject::PropertyVar(dmPhysics::GetContactProcessingThreshold3D(component->m_Object3D));
+            return dmGameObject::PROPERTY_RESULT_OK;
+        }
+        else if (params.m_PropertyId == PROP_LINEAR_SLEEPING_THRESHOLD)
+        {
+            out_value.m_Variant = dmGameObject::PropertyVar(dmPhysics::GetLinearSleepingThreshold3D(component->m_Object3D));
+            return dmGameObject::PROPERTY_RESULT_OK;
+        }
+        else if (params.m_PropertyId == PROP_ANGULAR_SLEEPING_THRESHOLD)
+        {
+            out_value.m_Variant = dmGameObject::PropertyVar(dmPhysics::GetAngularSleepingThreshold3D(component->m_Object3D));
+            return dmGameObject::PROPERTY_RESULT_OK;
+        }
         return dmGameObject::PROPERTY_RESULT_NOT_FOUND;
     }
 
@@ -650,6 +677,51 @@ namespace dmGameSystem
         {
             return dmGameObject::PROPERTY_RESULT_READ_ONLY;
         }
+        else if (params.m_PropertyId == PROP_CONTACT_PROCESSING_THRESHOLD)
+        {
+            if (params.m_Value.m_Type != dmGameObject::PROPERTY_TYPE_NUMBER)
+            {
+                return dmGameObject::PROPERTY_RESULT_TYPE_MISMATCH;
+            }
+            dmPhysics::SetContactProcessingThreshold3D(component->m_Object3D, params.m_Value.m_Number);
+            return dmGameObject::PROPERTY_RESULT_OK;
+        }
+        else if (params.m_PropertyId == PROP_LINEAR_FACTOR)
+        {
+            if (params.m_Value.m_Type != dmGameObject::PROPERTY_TYPE_VECTOR3)
+            {
+                return dmGameObject::PROPERTY_RESULT_TYPE_MISMATCH;
+            }
+            dmPhysics::SetLinearFactor3D(component->m_Object3D, dmVMath::Vector3(params.m_Value.m_V4[0], params.m_Value.m_V4[1], params.m_Value.m_V4[2]));
+            return dmGameObject::PROPERTY_RESULT_OK;
+        }
+        else if (params.m_PropertyId == PROP_ANGULAR_FACTOR)
+        {
+            if (params.m_Value.m_Type != dmGameObject::PROPERTY_TYPE_VECTOR3)
+            {
+                return dmGameObject::PROPERTY_RESULT_TYPE_MISMATCH;
+            }
+            dmPhysics::SetAngularFactor3D(component->m_Object3D, dmVMath::Vector3(params.m_Value.m_V4[0], params.m_Value.m_V4[1], params.m_Value.m_V4[2]));
+            return dmGameObject::PROPERTY_RESULT_OK;
+        }
+        else if (params.m_PropertyId == PROP_LINEAR_SLEEPING_THRESHOLD)
+        {
+            if (params.m_Value.m_Type != dmGameObject::PROPERTY_TYPE_NUMBER)
+            {
+                return dmGameObject::PROPERTY_RESULT_TYPE_MISMATCH;
+            }
+            dmPhysics::SetLinearSleepingThreshold3D(component->m_Object3D, params.m_Value.m_Number);
+            return dmGameObject::PROPERTY_RESULT_OK;
+        }
+        else if (params.m_PropertyId == PROP_ANGULAR_SLEEPING_THRESHOLD)
+        {
+            if (params.m_Value.m_Type != dmGameObject::PROPERTY_TYPE_NUMBER)
+            {
+                return dmGameObject::PROPERTY_RESULT_TYPE_MISMATCH;
+            }
+            dmPhysics::SetAngularSleepingThreshold3D(component->m_Object3D, params.m_Value.m_Number);
+            return dmGameObject::PROPERTY_RESULT_OK;
+        }
         return dmGameObject::PROPERTY_RESULT_NOT_FOUND;
     }
 
diff --git a/engine/gamesys/src/gamesys/components/comp_collision_object_private.h b/engine/gamesys/src/gamesys/components/comp_collision_object_private.h
index 2ec67baf3f..23df6a61da 100644
--- a/engine/gamesys/src/gamesys/components/comp_collision_object_private.h
+++ b/engine/gamesys/src/gamesys/components/comp_collision_object_private.h
@@ -20,12 +20,23 @@
 
 namespace dmGameSystem
 {
-    static const dmhash_t PROP_LINEAR_DAMPING   = dmHashString64("linear_damping");
-    static const dmhash_t PROP_ANGULAR_DAMPING  = dmHashString64("angular_damping");
-    static const dmhash_t PROP_LINEAR_VELOCITY  = dmHashString64("linear_velocity");
-    static const dmhash_t PROP_ANGULAR_VELOCITY = dmHashString64("angular_velocity");
-    static const dmhash_t PROP_MASS             = dmHashString64("mass");
-    static const dmhash_t PROP_BULLET           = dmHashString64("bullet");
+    static const dmhash_t PROP_LINEAR_DAMPING               = dmHashString64("linear_damping");
+    static const dmhash_t PROP_ANGULAR_DAMPING              = dmHashString64("angular_damping");
+    static const dmhash_t PROP_LINEAR_VELOCITY              = dmHashString64("linear_velocity");
+    static const dmhash_t PROP_ANGULAR_VELOCITY             = dmHashString64("angular_velocity");
+    static const dmhash_t PROP_MASS                         = dmHashString64("mass");
+    static const dmhash_t PROP_BULLET                       = dmHashString64("bullet");
+
+    // 3D-only properties
+    static const dmhash_t PROP_LINEAR_FACTOR                        = dmHashString64("linear_factor");
+    static const dmhash_t PROP_ANGULAR_FACTOR                       = dmHashString64("angular_factor");
+    static const dmhash_t PROP_CONTACT_PROCESSING_THRESHOLD         = dmHashString64("contact_processing_threshold");
+    static const dmhash_t PROP_LINEAR_SLEEPING_THRESHOLD            = dmHashString64("linear_sleeping_threshold");
+    static const dmhash_t PROP_ANGULAR_SLEEPING_THRESHOLD           = dmHashString64("angular_sleeping_threshold");
+    static const dmhash_t PROP_ADDITIONAL_DAMPING                   = dmHashString64("additional_damping");
+    static const dmhash_t PROP_ADDITIONAL_DAMPING_FACTOR            = dmHashString64("additional_damping_factor");
+    static const dmhash_t PROP_ADDITIONAL_LINEAR_DAMPING_THRESHOLD  = dmHashString64("additional_linear_damping_threshold");
+    static const dmhash_t PROP_ADDITIONAL_ANGULAR_DAMPING_THRESHOLD = dmHashString64("additional_angular_damping_threshold");
 
     enum EventMask
     {
diff --git a/engine/physics/src/physics/physics.h b/engine/physics/src/physics/physics.h
index fbe14ea581..dec67bf830 100644
--- a/engine/physics/src/physics/physics.h
+++ b/engine/physics/src/physics/physics.h
@@ -1104,6 +1104,19 @@ namespace dmPhysics
     bool GetMaskBit3D(HCollisionObject3D collision_object, uint16_t groupbit);
     void SetMaskBit3D(HWorld3D world, HCollisionObject3D collision_object, uint16_t groupbit, bool boolvalue);
 
+    void SetAngularFactor3D(HCollisionObject3D collision_object, const dmVMath::Vector3& factor);
+    void SetLinearFactor3D(HCollisionObject3D collision_object, const dmVMath::Vector3& factor);
+    dmVMath::Vector3 GetAngularFactor3D(HCollisionObject3D collision_object);
+    dmVMath::Vector3 GetLinearFactor3D(HCollisionObject3D collision_object);
+
+    float GetContactProcessingThreshold3D(HCollisionObject3D collision_object);
+    void SetContactProcessingThreshold3D(HCollisionObject3D collision_object, float contact_processing_threshold);
+
+    float GetLinearSleepingThreshold3D(HCollisionObject3D collision_object);
+    void SetLinearSleepingThreshold3D(HCollisionObject3D collision_object, float linear_sleeping_threshold);
+    float GetAngularSleepingThreshold3D(HCollisionObject3D collision_object);
+    void SetAngularSleepingThreshold3D(HCollisionObject3D collision_object, float angular_sleeping_threshold);
+
     /**
      * Container of data for ray cast queries.
      */
diff --git a/engine/physics/src/physics/physics_3d.cpp b/engine/physics/src/physics/physics_3d.cpp
index 69c27889f3..db25a8c9f6 100644
--- a/engine/physics/src/physics/physics_3d.cpp
+++ b/engine/physics/src/physics/physics_3d.cpp
@@ -744,6 +744,10 @@ namespace dmPhysics
             rb_info.m_restitution = data.m_Restitution;
             rb_info.m_linearDamping = data.m_LinearDamping;
             rb_info.m_angularDamping = data.m_AngularDamping;
+            if (data.m_Bullet) {
+                dmLogInfo("Additional damping is enabled");
+                rb_info.m_additionalDamping = true;
+            }
             btRigidBody* body = new btRigidBody(rb_info);
             float angular_factor = 1.0f;
             if (data.m_LockedRotation) {
@@ -1170,6 +1174,107 @@ namespace dmPhysics
 		}
 	}
 
+    Vector3 GetLinearFactor3D(HCollisionObject3D collision_object)
+    {
+        Vector3 linear_factor(0.0f, 0.0f, 0.0f);
+        btRigidBody* body = btRigidBody::upcast(GetCollisionObject(collision_object));
+        if (body != 0x0)
+        {
+            const btVector3& v = body->getLinearFactor();
+            FromBt(v, linear_factor, 1.0f);
+        }
+        return linear_factor;
+    }
+
+    Vector3 GetAngularFactor3D(HCollisionObject3D collision_object)
+    {
+        Vector3 angular_factor(0.0f, 0.0f, 0.0f);
+        btRigidBody* body = btRigidBody::upcast(GetCollisionObject(collision_object));
+        if (body != 0x0)
+        {
+            const btVector3& v = body->getAngularFactor();
+            FromBt(v, angular_factor, 1.0f);
+        }
+        return angular_factor;
+    }
+
+    void SetLinearFactor3D(HCollisionObject3D collision_object, const Vector3& factor)
+    {
+        btRigidBody* body = btRigidBody::upcast(GetCollisionObject(collision_object));
+        if (body != 0x0)
+        {
+            btVector3 bt_factor;
+            ToBt(factor, bt_factor, 1.0f);
+            body->setLinearFactor(bt_factor);
+        }
+    }
+
+    void SetAngularFactor3D(HCollisionObject3D collision_object, const Vector3& factor)
+    {
+        btRigidBody* body = btRigidBody::upcast(GetCollisionObject(collision_object));
+        if (body != 0x0)
+        {
+            btVector3 bt_factor;
+            ToBt(factor, bt_factor, 1.0f);
+            body->setAngularFactor(bt_factor);
+        }
+    }
+
+    float GetContactProcessingThreshold3D(HCollisionObject3D collision_object) {
+        btCollisionObject* co = GetCollisionObject(collision_object);
+        return co->getContactProcessingThreshold();
+    }
+
+    void SetContactProcessingThreshold3D(HCollisionObject3D collision_object, float contact_processing_threshold) {
+        btCollisionObject* co = GetCollisionObject(collision_object);
+        co->setContactProcessingThreshold(contact_processing_threshold);
+    }
+
+    float GetLinearSleepingThreshold3D(HCollisionObject3D collision_object) {
+        btCollisionObject* co = GetCollisionObject(collision_object);
+        btRigidBody* body = btRigidBody::upcast(co);
+        if (body != 0x0) {
+            return body->getLinearSleepingThreshold();
+        } else {
+            return 0.0f;
+        }
+    }
+
+    void SetLinearSleepingThreshold3D(HCollisionObject3D collision_object, float linear_sleeping_threshold) {
+        btCollisionObject* co = GetCollisionObject(collision_object);
+        btRigidBody* body = btRigidBody::upcast(co);
+        if (body != 0x0) {
+            body->setSleepingThresholds(linear_sleeping_threshold, body->getAngularSleepingThreshold());
+        }
+    }
+
+    float GetAngularSleepingThreshold3D(HCollisionObject3D collision_object) {
+        btCollisionObject* co = GetCollisionObject(collision_object);
+        btRigidBody* body = btRigidBody::upcast(co);
+        if (body != 0x0) {
+            return body->getAngularSleepingThreshold();
+        } else {
+            return 0.0f;
+        }
+    }
+
+    void SetAngularSleepingThreshold3D(HCollisionObject3D collision_object, float angular_sleeping_threshold) {
+        btCollisionObject* co = GetCollisionObject(collision_object);
+        btRigidBody* body = btRigidBody::upcast(co);
+        if (body != 0x0) {
+            body->setSleepingThresholds(body->getLinearSleepingThreshold(), angular_sleeping_threshold);
+        }
+    }
+
+    // bool GetAdditionalDamping3D(HCollisionObject3D collision_object) {
+    //     btCollisionObject* co = GetCollisionObject(collision_object);
+    //     btRigidBody* body = btRigidBody::upcast(co);
+    //     if (body != 0x0) {
+    //         return body->getAdditionalDamping();
+    //     }
+    //     return false;
+    // }
+
     void RequestRayCast3D(HWorld3D world, const RayCastRequest& request)
     {
         if (!world->m_RayCastRequests.Full())
diff --git a/scripts/build.py b/scripts/build.py
index ed172050f9..cd0f572678 100755
--- a/scripts/build.py
+++ b/scripts/build.py
@@ -2362,8 +2362,15 @@ class Configuration(object):
 
 
     def upload_to_archive(self, src_file, dst_path):
-        url = join(self.get_archive_path(), dst_path).replace("\\", "/")
-        self.upload_to_s3(src_file, url)
+        print("<!> upload_to_archive: src_file %s, dst_path %s" % (src_file, dst_path))
+        dst = os.path.join(self.defold_root, self.dynamo_home, "archive")
+        print("                       dst %s" % dst)
+        self._mkdirs(os.path.join(dst, os.path.dirname(dst_path)))
+        print("                       mkdirs %s" % os.path.join(dst, os.path.dirname(dst_path)))
+        if os.path.isdir(src_file):
+            self._copy_tree(src_file, os.path.join(dst, dst_path))
+        else:
+            self._copy(src_file, os.path.join(dst, dst_path))
 
 
     def download_from_s3(self, path, url):

diff --git a/build_tools/sdk.py b/build_tools/sdk.py
index 75d8864a2f..7b95642388 100644
--- a/build_tools/sdk.py
+++ b/build_tools/sdk.py
@@ -71,8 +71,8 @@ ANDROID_64_NDK_API_VERSION='21' # Android 5.0
 # Win32
 
 # The version we have prepackaged
-VERSION_WINDOWS_SDK_10="10.0.20348.0"
-VERSION_WINDOWS_MSVC_2022="14.37.32822"
+VERSION_WINDOWS_SDK_10="10.0.26100.0"
+VERSION_WINDOWS_MSVC_2022="14.44.35207"
 PACKAGES_WIN32_TOOLCHAIN=f"Microsoft-Visual-Studio-2022-{VERSION_WINDOWS_MSVC_2022}"
 PACKAGES_WIN32_SDK_10=f"WindowsKits-{VERSION_WINDOWS_SDK_10}"
 
diff --git a/engine/gamesys/src/gamesys/components/bullet3d/comp_collision_object_bullet3d.cpp b/engine/gamesys/src/gamesys/components/bullet3d/comp_collision_object_bullet3d.cpp
index 6b88707a93..2b9f057fee 100644
--- a/engine/gamesys/src/gamesys/components/bullet3d/comp_collision_object_bullet3d.cpp
+++ b/engine/gamesys/src/gamesys/components/bullet3d/comp_collision_object_bullet3d.cpp
@@ -77,6 +77,8 @@ namespace dmGameSystem
     {
         DM_STATIC_ASSERT(sizeof(ShapeInfo::m_BoxDimensions) <= sizeof(dmVMath::Vector3), Invalid_Struct_Size);
 
+        dmLogInfo("PATCH: Bullet Physics 3D New World");
+
         PhysicsContextBullet3D* physics_context = (PhysicsContextBullet3D*) params.m_Context;
         if (params.m_MaxComponentInstances == 0 || physics_context->m_Context == 0x0)
         {
diff --git a/engine/graphics/src/vulkan/graphics_vulkan_swap_chain.cpp b/engine/graphics/src/vulkan/graphics_vulkan_swap_chain.cpp
index bd6d38ea53..1a586909a0 100644
--- a/engine/graphics/src/vulkan/graphics_vulkan_swap_chain.cpp
+++ b/engine/graphics/src/vulkan/graphics_vulkan_swap_chain.cpp
@@ -14,6 +14,7 @@
 
 #include <dlib/math.h>
 #include <dlib/array.h>
+#include <dlib/log.h>
 
 #include "graphics_vulkan_defines.h"
 #include "graphics_vulkan_private.h"
@@ -95,6 +96,8 @@ namespace dmGraphics
         uint32_t* wantedWidth, uint32_t* wantedHeight,
         bool wantVSync, SwapChainCapabilities& capabilities, SwapChain* swapChain)
     {
+        dmLogInfo("PATCH: Vulkan UpdateSwapChain");
+
         VkSwapchainKHR vk_old_swap_chain    = swapChain->m_SwapChain;
         VkDevice vk_device                  = logicalDevice->m_Device;
         VkPhysicalDevice vk_physical_device = physicalDevice->m_Device;
@@ -146,6 +149,9 @@ namespace dmGraphics
         // before we can acquire another image to render to"
         uint32_t swap_chain_image_count = capabilities.m_SurfaceCapabilities.minImageCount + 1;
 
+        dmLogInfo("PATCH: Vulkan minImageCount: %d", capabilities.m_SurfaceCapabilities.minImageCount);
+        dmLogInfo("PATCH: Vulkan maxImageCount: %d", capabilities.m_SurfaceCapabilities.maxImageCount);
+
         if (capabilities.m_SurfaceCapabilities.maxImageCount > 0)
         {
             swap_chain_image_count = dmMath::Clamp(swap_chain_image_count,
@@ -155,6 +161,8 @@ namespace dmGraphics
 
         swap_chain_image_count = dmMath::Min(swap_chain_image_count, (uint32_t) DM_MAX_FRAMES_IN_FLIGHT);
 
+        dmLogInfo("PATCH: Vulkan swap_chain_image_count: %d", swap_chain_image_count);
+
         VkSwapchainCreateInfoKHR vk_swap_chain_create_info;
         memset((void*)&vk_swap_chain_create_info, 0, sizeof(vk_swap_chain_create_info));
 
diff --git a/scripts/build.py b/scripts/build.py
index ed172050f9..cd0f572678 100755
--- a/scripts/build.py
+++ b/scripts/build.py
@@ -2362,8 +2362,15 @@ class Configuration(object):
 
 
     def upload_to_archive(self, src_file, dst_path):
-        url = join(self.get_archive_path(), dst_path).replace("\\", "/")
-        self.upload_to_s3(src_file, url)
+        print("<!> upload_to_archive: src_file %s, dst_path %s" % (src_file, dst_path))
+        dst = os.path.join(self.defold_root, self.dynamo_home, "archive")
+        print("                       dst %s" % dst)
+        self._mkdirs(os.path.join(dst, os.path.dirname(dst_path)))
+        print("                       mkdirs %s" % os.path.join(dst, os.path.dirname(dst_path)))
+        if os.path.isdir(src_file):
+            self._copy_tree(src_file, os.path.join(dst, dst_path))
+        else:
+            self._copy(src_file, os.path.join(dst, dst_path))
 
 
     def download_from_s3(self, path, url):

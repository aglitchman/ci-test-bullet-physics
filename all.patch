diff --git a/build_tools/sdk.py b/build_tools/sdk.py
index 75d8864a2f..7b95642388 100644
--- a/build_tools/sdk.py
+++ b/build_tools/sdk.py
@@ -71,8 +71,8 @@ ANDROID_64_NDK_API_VERSION='21' # Android 5.0
 # Win32
 
 # The version we have prepackaged
-VERSION_WINDOWS_SDK_10="10.0.20348.0"
-VERSION_WINDOWS_MSVC_2022="14.37.32822"
+VERSION_WINDOWS_SDK_10="10.0.26100.0"
+VERSION_WINDOWS_MSVC_2022="14.44.35207"
 PACKAGES_WIN32_TOOLCHAIN=f"Microsoft-Visual-Studio-2022-{VERSION_WINDOWS_MSVC_2022}"
 PACKAGES_WIN32_SDK_10=f"WindowsKits-{VERSION_WINDOWS_SDK_10}"
 
diff --git a/engine/gamesys/src/gamesys/components/bullet3d/comp_collision_object_bullet3d.cpp b/engine/gamesys/src/gamesys/components/bullet3d/comp_collision_object_bullet3d.cpp
index 6b88707a93..892fd98464 100644
--- a/engine/gamesys/src/gamesys/components/bullet3d/comp_collision_object_bullet3d.cpp
+++ b/engine/gamesys/src/gamesys/components/bullet3d/comp_collision_object_bullet3d.cpp
@@ -77,6 +77,8 @@ namespace dmGameSystem
     {
         DM_STATIC_ASSERT(sizeof(ShapeInfo::m_BoxDimensions) <= sizeof(dmVMath::Vector3), Invalid_Struct_Size);
 
+        dmLogInfo("PATCH: Bullet Physics 3D New World");
+
         PhysicsContextBullet3D* physics_context = (PhysicsContextBullet3D*) params.m_Context;
         if (params.m_MaxComponentInstances == 0 || physics_context->m_Context == 0x0)
         {
@@ -598,6 +600,11 @@ namespace dmGameSystem
             out_value.m_Variant = dmGameObject::PropertyVar(dmPhysics::GetAngularDamping3D(component->m_Object3D));
             return dmGameObject::PROPERTY_RESULT_OK;
         }
+        else if (params.m_PropertyId == PROP_CONTACT_PROCESSING_THRESHOLD)
+        {
+            out_value.m_Variant = dmGameObject::PropertyVar(dmPhysics::GetContactProcessingThreshold3D(component->m_Object3D));
+            return dmGameObject::PROPERTY_RESULT_OK;
+        }
         return dmGameObject::PROPERTY_RESULT_NOT_FOUND;
     }
 
@@ -650,6 +657,15 @@ namespace dmGameSystem
         {
             return dmGameObject::PROPERTY_RESULT_READ_ONLY;
         }
+        else if (params.m_PropertyId == PROP_CONTACT_PROCESSING_THRESHOLD)
+        {
+            if (params.m_Value.m_Type != dmGameObject::PROPERTY_TYPE_NUMBER)
+            {
+                return dmGameObject::PROPERTY_RESULT_TYPE_MISMATCH;
+            }
+            dmPhysics::SetContactProcessingThreshold3D(component->m_Object3D, params.m_Value.m_Number);
+            return dmGameObject::PROPERTY_RESULT_OK;
+        }
         return dmGameObject::PROPERTY_RESULT_NOT_FOUND;
     }
 
diff --git a/engine/gamesys/src/gamesys/components/comp_collision_object_private.h b/engine/gamesys/src/gamesys/components/comp_collision_object_private.h
index 2ec67baf3f..5cd2bb878f 100644
--- a/engine/gamesys/src/gamesys/components/comp_collision_object_private.h
+++ b/engine/gamesys/src/gamesys/components/comp_collision_object_private.h
@@ -27,6 +27,10 @@ namespace dmGameSystem
     static const dmhash_t PROP_MASS             = dmHashString64("mass");
     static const dmhash_t PROP_BULLET           = dmHashString64("bullet");
 
+    // void	setContactProcessingThreshold( btScalar contactProcessingThreshold)
+    // btScalar	getContactProcessingThreshold() const
+    static const dmhash_t PROP_CONTACT_PROCESSING_THRESHOLD = dmHashString64("contact_processing_threshold");
+
     enum EventMask
     {
         EVENT_MASK_COLLISION = 1 << 0,
diff --git a/engine/graphics/src/vulkan/graphics_vulkan.cpp b/engine/graphics/src/vulkan/graphics_vulkan.cpp
index ac651ef28d..57a2d83574 100644
--- a/engine/graphics/src/vulkan/graphics_vulkan.cpp
+++ b/engine/graphics/src/vulkan/graphics_vulkan.cpp
@@ -943,6 +943,8 @@ namespace dmGraphics
 
     bool InitializeVulkan(HContext _context)
     {
+        dmLogInfo("PATCH: Vulkan InitializeVulkan");
+
         VulkanContext* context = (VulkanContext*) _context;
         VkResult res = CreateWindowSurface(context->m_Window, context->m_Instance, &context->m_WindowSurface, dmPlatform::GetWindowStateParam(context->m_Window, dmPlatform::WINDOW_STATE_HIGH_DPI));
         if (res != VK_SUCCESS)
diff --git a/engine/graphics/src/vulkan/graphics_vulkan_swap_chain.cpp b/engine/graphics/src/vulkan/graphics_vulkan_swap_chain.cpp
index bd6d38ea53..1a586909a0 100644
--- a/engine/graphics/src/vulkan/graphics_vulkan_swap_chain.cpp
+++ b/engine/graphics/src/vulkan/graphics_vulkan_swap_chain.cpp
@@ -14,6 +14,7 @@
 
 #include <dlib/math.h>
 #include <dlib/array.h>
+#include <dlib/log.h>
 
 #include "graphics_vulkan_defines.h"
 #include "graphics_vulkan_private.h"
@@ -95,6 +96,8 @@ namespace dmGraphics
         uint32_t* wantedWidth, uint32_t* wantedHeight,
         bool wantVSync, SwapChainCapabilities& capabilities, SwapChain* swapChain)
     {
+        dmLogInfo("PATCH: Vulkan UpdateSwapChain");
+
         VkSwapchainKHR vk_old_swap_chain    = swapChain->m_SwapChain;
         VkDevice vk_device                  = logicalDevice->m_Device;
         VkPhysicalDevice vk_physical_device = physicalDevice->m_Device;
@@ -146,6 +149,9 @@ namespace dmGraphics
         // before we can acquire another image to render to"
         uint32_t swap_chain_image_count = capabilities.m_SurfaceCapabilities.minImageCount + 1;
 
+        dmLogInfo("PATCH: Vulkan minImageCount: %d", capabilities.m_SurfaceCapabilities.minImageCount);
+        dmLogInfo("PATCH: Vulkan maxImageCount: %d", capabilities.m_SurfaceCapabilities.maxImageCount);
+
         if (capabilities.m_SurfaceCapabilities.maxImageCount > 0)
         {
             swap_chain_image_count = dmMath::Clamp(swap_chain_image_count,
@@ -155,6 +161,8 @@ namespace dmGraphics
 
         swap_chain_image_count = dmMath::Min(swap_chain_image_count, (uint32_t) DM_MAX_FRAMES_IN_FLIGHT);
 
+        dmLogInfo("PATCH: Vulkan swap_chain_image_count: %d", swap_chain_image_count);
+
         VkSwapchainCreateInfoKHR vk_swap_chain_create_info;
         memset((void*)&vk_swap_chain_create_info, 0, sizeof(vk_swap_chain_create_info));
 
diff --git a/engine/physics/src/physics/physics.h b/engine/physics/src/physics/physics.h
index fbe14ea581..022ad965ee 100644
--- a/engine/physics/src/physics/physics.h
+++ b/engine/physics/src/physics/physics.h
@@ -1104,6 +1104,9 @@ namespace dmPhysics
     bool GetMaskBit3D(HCollisionObject3D collision_object, uint16_t groupbit);
     void SetMaskBit3D(HWorld3D world, HCollisionObject3D collision_object, uint16_t groupbit, bool boolvalue);
 
+    float GetContactProcessingThreshold3D(HCollisionObject3D collision_object);
+    void SetContactProcessingThreshold3D(HCollisionObject3D collision_object, float contact_processing_threshold);
+
     /**
      * Container of data for ray cast queries.
      */
diff --git a/engine/physics/src/physics/physics_3d.cpp b/engine/physics/src/physics/physics_3d.cpp
index 69c27889f3..781563e12d 100644
--- a/engine/physics/src/physics/physics_3d.cpp
+++ b/engine/physics/src/physics/physics_3d.cpp
@@ -1170,6 +1170,16 @@ namespace dmPhysics
 		}
 	}
 
+    float GetContactProcessingThreshold3D(HCollisionObject3D collision_object) {
+        btCollisionObject* co = GetCollisionObject(collision_object);
+        return co->getContactProcessingThreshold();
+    }
+
+    void SetContactProcessingThreshold3D(HCollisionObject3D collision_object, float contact_processing_threshold) {
+        btCollisionObject* co = GetCollisionObject(collision_object);
+        co->setContactProcessingThreshold(contact_processing_threshold);
+    }
+
     void RequestRayCast3D(HWorld3D world, const RayCastRequest& request)
     {
         if (!world->m_RayCastRequests.Full())
diff --git a/scripts/build.py b/scripts/build.py
index ed172050f9..cd0f572678 100755
--- a/scripts/build.py
+++ b/scripts/build.py
@@ -2362,8 +2362,15 @@ class Configuration(object):
 
 
     def upload_to_archive(self, src_file, dst_path):
-        url = join(self.get_archive_path(), dst_path).replace("\\", "/")
-        self.upload_to_s3(src_file, url)
+        print("<!> upload_to_archive: src_file %s, dst_path %s" % (src_file, dst_path))
+        dst = os.path.join(self.defold_root, self.dynamo_home, "archive")
+        print("                       dst %s" % dst)
+        self._mkdirs(os.path.join(dst, os.path.dirname(dst_path)))
+        print("                       mkdirs %s" % os.path.join(dst, os.path.dirname(dst_path)))
+        if os.path.isdir(src_file):
+            self._copy_tree(src_file, os.path.join(dst, dst_path))
+        else:
+            self._copy(src_file, os.path.join(dst, dst_path))
 
 
     def download_from_s3(self, path, url):
